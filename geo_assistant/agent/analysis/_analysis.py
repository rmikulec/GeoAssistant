import pathlib
import json
from typing import Type, Sequence, Callable, Literal
from enum import Enum
from openai import AsyncOpenAI
from openai.types.responses import ParsedResponse
from pydantic import BaseModel, Field, create_model
from sqlalchemy import Engine, text
from jinja2 import Template

from geo_assistant.config import Configuration
from geo_assistant.logging import get_logger
from geo_assistant.table_registry import Table
from geo_assistant._sql._sql_exec import execute_template_sql
from geo_assistant.agent.analysis.report import GISReport, TableCreated
from geo_assistant.agent.analysis._steps import STEP_TYPES, _SQLStep, _ReportingStep
from geo_assistant.agent.analysis._exceptions import AnalysisSQLStepFailed

TEMPATE_PATH = pathlib.Path(__file__).resolve().parent / "templates"
logger = get_logger(__name__)


def make_enum(name: str, *values: Sequence[str]) -> Type[Enum]:
    """
    Dynamically constructs an Enum subclass.
    
    Each member will be named as the upper-cased version of the value,
    and its `.value` will be the original string.

    Args:
        name (str): The name of the Enum Class
        *values (Sequence[str]): A sequence of values that will populate the enum
    
    Returns:
        Type[Enum]: The autogenerated Enum Class populated with *values
    """
    members = { val.upper(): val for val in values }
    return Enum(name, members)


class AnalysisPlanStep(BaseModel):
    type: Literal["Merge", "Aggregate", "Filter", "Buffer", "Plot", "Save"]
    name: str = Field(description="snake_case name of the step")
    display_name: str = Field(description="Readable name of the step")
    reason: str = Field(description="Why this step is being performed")
    method: str = Field(description=
        (
            "A readable explanation on what the query/func should exactly do"
            "This should not be code. Instead it should be instructions on how to code."
        )
    )
    dependent_on: list[int] = Field(description="Indices of the previous steps this one is dependent on")
    intermediate: bool = Field(description="Wheter this step is only used to get to the next, or is it part of the final output")


class AnalysisPlan(BaseModel):
    """
    Schema used to prompt openai to build a plan for the analysis
    """
    name: str = Field(description="snake_case name of the plan")
    display_name: str = Field(description="Readable name of the plan")
    plan: str
    steps: list[AnalysisPlanStep]



class GISAnalyst:
    """
    Analysis base class, this is not intended to be directly used. Instead call
        `build_model` with the appropriate `step_types`, `fields` and `tables`
    """

    def __init__(self, tables: list[Table]):
        self.tables: list[Table] = tables
        #Private variables to not be exposed by pydantic, but used for running the analysis
        self.planning_queue: list[AnalysisPlanStep] = []
        self.generated_steps: list[_SQLStep] = []
        self.to_destroy_: list[TableCreated] = []
        self.client = AsyncOpenAI(api_key=Configuration.openai_key)

        self.current_plan = None

    def _from_dict(self, plan_dict: dict):
        plan_ = AnalysisPlan.model_validate(plan_dict)
        self.planning_queue = plan_.steps

    async def plan(self, goal: str):
        plan_system_message = Template(
            (TEMPATE_PATH / "plan.j2").read_text(), 
            trim_blocks=True, 
            lstrip_blocks=True
        ).render(
            tables=self.tables,
            schema_json=json.dumps([
                t.model_json_schema()
                for t in STEP_TYPES.values()
            ],
            indent=2
        )
        )
        # Query for the plan
        res: ParsedResponse[AnalysisPlan] = await self.client.responses.parse(
            input=[
                {'role': 'developer', 'content': plan_system_message},
                {'role': 'user', 'content': goal}
            ],
            text_format=AnalysisPlan,
            model="o4-mini",
            reasoning={
                "effort":"high"
            }
        )
        self.planning_queue = res.output_parsed.steps
        self.current_plan = {
            "name": res.output_parsed.name,
            "display_name": res.output_parsed.display_name,
            "plan": res.output_parsed.plan
        }


    async def walkthrough(self):
            # Pop the next step from the queue
        while self.planning_queue:
            step = self.planning_queue.pop(0)

            # Generate the system message using the step
            step_system_message = Template(
                (TEMPATE_PATH / "plan.j2").read_text(), 
                trim_blocks=True, 
                lstrip_blocks=True
            ).render(
                step_json=step.model_dump_json(indent=2),
                tables=self.tables,
                gen_steps=self.generated_steps
            )

            # Resolve the enums for generating the sql params
            columns = [
                table.columns
                for table in self.tables
            ]
            columns = sum(columns, [])
            tables = [table.name for table in self.tables]
            # Add any enum values from a table it is dependent on, allowing it to use it
            #   when generating the next step
            for i in step.dependent_on:
                completion = self.generated_steps[i]
                columns.extend(completion.columns)
                tables.append(completion.table_)

            # Create the model with these enum values
            StepModel = STEP_TYPES[step.type]._build_step_model(
                columns_enum=make_enum("ColumnsEnum", *columns),
                tables_enum=make_enum("TablesEnum", *tables)
            )

            # Hit openai
            res: ParsedResponse[StepModel] = await self.client.responses.parse(
                input=[
                    {'role': 'developer', 'content': step_system_message},
                    {'role': 'user', 'content': step.method}
                ],
                text_format=StepModel,
                model="o4-mini",
                reasoning={
                    "effort":"high"
                }
            )
            # Mark the table name and add it to completed
            sql_params = res.output_parsed
            sql_params.table_ = step.name
            sql_params.to_destroy_ = step.intermediate
            self.generated_steps.append(sql_params)

            yield step



    async def execute(self, engine: Engine):
        """
        Executes the pregenerated plan. This will populate a new schema in the database, filled
            with any tables that this particular analysis used. It returns a strucutred "GISReport"
            of the results for each step in the analysis. This report can then be interpreted or
            displayed in any way.
        
        Args:
            engine (sqlalchemy.Engine): A sqlalchemy engine to be used to run the query.
        
        Returns:
            GISReport: A pydantic model containing all the results from each step in the analysis
        """

        # Create the new schema (if it doesnt exists already) and grant pg-tileserv permissions to
        #   use it
        with engine.begin() as conn:
            sql = text(
                (
                    f"CREATE SCHEMA IF NOT EXISTS {self.plan['name']} AUTHORIZATION {Configuration.db_tileserv_role};"
                    f"GRANT USAGE ON SCHEMA {self.plan['name']} TO {Configuration.db_tileserv_role};"
                )
            )
            conn.execute(sql)

        while self.generated_steps:
            step = self.generated_steps.pop(0)
        # Run each step, saving result to the 'items' array
            logger.info(f"Executing {step.name}")
            if issubclass(step, _SQLStep):
                try:
                    item = step._execute(engine, self.name)
                    if step.to_destroy_:
                        self.to_destroy_.append(item)
                    yield item
                except Exception as e:
                    raise AnalysisSQLStepFailed(
                        analysis_name=self.name,
                        step=step,
                        exception=e
                    )
            # TODO: If any more reporting steps get added, new logic will need to be implemented
            #   here
            elif issubclass(step, _ReportingStep):
                yield step.export()
        

    async def cleanup(self, engine: Engine):
        with engine.begin():
            for table in self.to_destroy_:
                execute_template_sql(
                    engine=engine,
                    template_name="drop",
                    schema_name=self.plan['name'],
                    table_name=table.table
                )