from dotenv import load_dotenv
load_dotenv()

import logging
import pathlib
import openai
import json

from typing import Callable, Any


from geo_assistant.handlers import MapHandler, DataHandler, GeoFilter
from geo_assistant.doc_stores import FieldDefinitionStore, SupplementalInfoStore
from geo_assistant import tools
from geo_assistant.config import Configuration


logger = logging.getLogger(__name__)

GEO_AGENT_SYSTEM_MESSAGE = """
You are a geo-assistant who is an expert at making maps in GIS software. You will be given access
to a large dataset of GeoJSON data, and you are tasked to keep the map in a state that best reflects
the conversation with the user.

To do so, you will be given access to the following tools:
  - add_map_layer: You can add a new layer to the map, with the filters and color of your choosing
  - remove_map_layer: You can remove a layer when it is no longer applicable to the conversation
  - reset_map: You can reset the map to have 0 layers and start over

Here is the current status of the map:
{map_status}

Here is any other relevant information:
{supplement_information}
"""


class GeoAgent:
    """
    OpenAI powered agent to filter parcels and answer user questions

    Methods:
        - chat(user_message: str, field_defs: list[dict]): Function used to 'chat' with the
            GeoAgent. To use, must pass a user-message and a list of field definitions. Chat will
            then use OpenAI SDK to select proper filters (based on the field definitions) and
            answer the user in a conversational way
    """

    def __init__(
        self, 
        map_handler: MapHandler,
        data_handler: DataHandler,
        field_store: FieldDefinitionStore = None,
        info_store: SupplementalInfoStore = None,
        model: str = Configuration.inference_model,
        supplement_info: str = None
    ):
        self.model = model
        self.supplement_info = supplement_info
        self.map_handler = map_handler
        self.data_handler = data_handler
        self.client = openai.AsyncOpenAI(api_key=pathlib.Path("./openai.key").read_text())

        if field_store is None:
            self.field_store = FieldDefinitionStore(version=Configuration.field_def_store_version)
        else:
            self.field_store = field_store
        
        if info_store is None:
            self.info_store = SupplementalInfoStore(version=Configuration.info_store_version)
        else:
            self.info_store = info_store

        self.messages = [
            {'role': 'developer', 'content': GEO_AGENT_SYSTEM_MESSAGE.format(
                    map_status="Graph not updated yet.",
                    supplement_information=supplement_info
                )    
            }
        ]

        self.tools: dict[str, Callable[..., Any]] = {
            "add_map_layer":    self.map_handler._add_map_layer,
            "remove_map_layer": self.map_handler._remove_map_layer,
            "reset_map":        self.map_handler._reset_map,
        }

    def _update_dev_message(self):
        self.messages[0] = {'role': 'developer', 'content': GEO_AGENT_SYSTEM_MESSAGE.format(
                map_status=json.dumps(self.map_handler.status,indent=2),
                supplement_information=self.supplement_info
            )    
        }
    

    async def _get_field_defs(self, message: str, k: int = 5):
        if len(self.messages)>1:
            message += " " + self.messages[-1]['content']
        field_defs = await self.field_store.query(message, k=5)
        return field_defs

    async def chat(self, user_message: str) -> str:
        """
        Function used to 'chat' with the
            GeoAgent. To use, must pass a user-message and a list of field definitions. Chat will
            then use OpenAI SDK to select proper filters (based on the field definitions) and
            answer the user in a conversational way

        Args:
            user_message(str): The message inputed by the user
            field_defs(list[dict]): Field Definitions that can be used to filter the GeoDataframe
                These can be obtained by querying the "FieldDefinitionStore"
        Returns:
            str: The message generated by the LLM to return to the user
        """
        self.messages.append(
            {'role': 'user', 'content': user_message}
        )

        field_defs = await self._get_field_defs(user_message)
        context = "\n".join(await self.info_store.query(user_message))

        tool_defs = [
            tools._build_add_layer_def(field_defs),
            tools._build_remove_layer_def(self.map_handler),
            tools._build_reset_def()
        ]

        res = await self.client.responses.create(
            model=self.model,
            input=self.messages,
            tools=tool_defs
        )

        made_tool_calls = False
        for tool_call in res.output:
            self.messages.append(tool_call)
            if tool_call.type != "function_call":
                continue

            made_tool_calls = True
            kwargs = json.loads(tool_call.arguments)

            print(f"Calling {tool_call.name} with filters: {kwargs}")


            if tool_call.name == "add_map_layer":   
                # Extract filters from the kwargs
                filter_names = [
                    name
                    for name in kwargs.keys()
                    if name not in ['layer_id', 'color', 'style']
                ]
                filters = []
                for filter_name in filter_names:
                    filter_details = kwargs.pop(filter_name)
                    filters.append(GeoFilter(
                        field=filter_name,
                        value=filter_details['value'],
                        op=filter_details['operator']
                    ))
            
                # Run the function with the new filter arg injected
                try:
                    kwargs['filters'] = filters
                    self.tools['add_map_layer'](**kwargs)
                    # This tool has a custom response to handle how many parcels were selected
                    tool_response = f"{self.data_handler.filter_count(filters)} parcels found"
                except Exception as e:
                    tool_response = f"Tool call: {tool_call.name} failed, raised: {str(e)}"
            else:
                try:
                    tool_response = self.tools[tool_call.name](**kwargs)
                except Exception as e:
                    tool_response = f"Tool call: {tool_call.name} failed, raised: {str(e)}"
            print(f"Tool Response: {tool_response}")
            self._update_dev_message()
            self.messages.append({
                "type": "function_call_output",
                "call_id": tool_call.call_id,
                "output": tool_response
            })
    
        if made_tool_calls:
            res = await self.client.responses.create(
                model=self.model,
                input=self.messages,
            )
        
        ai_message = res.output_text
        self.messages.append({'role': 'assistant', 'content': ai_message})
        return ai_message