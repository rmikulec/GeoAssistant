import geopandas as gpd
import pandas as pd
import pathlib
import openai
import json


GEO_AGENT_SYSTEM_MESSAGE = """
You are a geo-assistant designed to help users explore geospatial parcel data via natural-language conversation.
When the user asks to view or filter parcels, you must invoke the `filter_parcels` tool. Build its `filters` argument dynamically by mapping the user’s criteria (e.g. zoning, borough, acreage) to field names and values.
If a certain filter is not needed, use the value 'ignore' to skip

Always use this JSON format for the tool call:

```json
{
  "name": "filter_parcels",
  "arguments": {
    "filters": {
      "<field_name>": "<value>",
      ...
    }
  }
}
"""


class GeoAgent:
    """
    OpenAI powered agent to filter parcels and answer user questions

    Methods:
        - chat(user_message: str, field_defs: list[dict]): Function used to 'chat' with the
            GeoAgent. To use, must pass a user-message and a list of field definitions. Chat will
            then use OpenAI SDK to select proper filters (based on the field definitions) and
            answer the user in a conversational way
    """

    def __init__(self, gdf: gpd.GeoDataFrame, model: str = "gpt-4o"):
        self.model = model
        self.client = openai.OpenAI(api_key=pathlib.Path("./openai.key").read_text())

        self.messages = [
            {'role': 'system', 'content': GEO_AGENT_SYSTEM_MESSAGE}
        ]

        self._gdf = gdf
        self.filtered_gdf: gpd.GeoDataFrame = gdf.copy()[["geometry", "Borough", "BBL"]]
    
    def _build_func_def(self, field_defs: list[dict]):
        """
        Private method to build an OpenAI Function JSON schema, based on a given set of field
            definitions
        """
        func_def = {
            "type": "function",
            "name": "filter_parcels",
            "description": "Return parcels matching the given field filters",
            "parameters": {
                "type": "object",
                "properties": {
                    "reset": {
                        "type": "boolean",
                        "description": "If true, will filter on the original set of parcels. If false, will apply a new filter to what was previously filtered",
                    }
                },
                "required":["reset"]
            }
        }

        for res in field_defs:
            func_def['parameters']['properties'][res['name']] = {
                "type": res['format'],
                "description": res['description'],
                "default": "ignore"
            }
            func_def['parameters']['required'].append(res['name'])

        return func_def
    

    def _filter_gdf(self, reset: bool = True, **filters) -> None:
        """
        Private method to be called by the LLM, in order to update the 'filtered_gdf"
        """
        gdf = self._gdf if reset else self.filtered_gdf

        # start with all‐True mask
        mask = pd.Series(True, index=gdf.index)

        # apply each filter
        for col, val in filters.items():
            if val == 'ignore':
                pass
            else:
                mask &= (gdf[col] == val)

        self.filtered_gdf = gdf[mask]
    

    def chat(self, user_message: str, field_defs: list[dict]) -> str:
        """
        Function used to 'chat' with the
            GeoAgent. To use, must pass a user-message and a list of field definitions. Chat will
            then use OpenAI SDK to select proper filters (based on the field definitions) and
            answer the user in a conversational way

        Args:
            user_message(str): The message inputed by the user
            field_defs(list[dict]): Field Definitions that can be used to filter the GeoDataframe
                These can be obtained by querying the "FieldDefinitionStore"
        Returns:
            str: The message generated by the LLM to return to the user
        """
        self.messages.append(
            {'role': 'user', 'content': user_message}
        )

        res = self.client.responses.create(
            model=self.model,
            input=self.messages,
            tools=[self._build_func_def(field_defs)]
        )

        made_tool_calls = False
        for tool_call in res.output:
            self.messages.append(tool_call)
            if tool_call.type != "function_call":
                continue

            made_tool_calls = True
            args = json.loads(tool_call.arguments)

            print(f"Calling with filters: {args}")
            self._filter_gdf(**args)
            self.messages.append({
                "type": "function_call_output",
                "call_id": tool_call.call_id,
                "output": f"{len(self.filtered_gdf)} parcels found"
            })

        if made_tool_calls:
            res = self.client.responses.create(
                model=self.model,
                input=self.messages,
            )
        
        
        ai_message = res.output[0].content[0].text
        self.messages.append({'role': 'assistant', 'content': ai_message})
        return ai_message